{"version":3,"sources":["../src/index.js"],"names":["REORG_SAFETY_BLOCK_AGE","detectProvider","web3","currentProvider","Aragon","constructor","daoAddress","options","defaultOptions","defaultGasPriceFn","provider","cache","forceLocalStorage","events","subscriptionDelayTime","Object","assign","configurationKeys","FORCE_LOCAL_STORAGE","SUBSCRIPTION_EVENT_DELAY","Number","isFinite","subscriptionEventDelay","Web3","ens","apm","ensRegistryAddress","ipfs","apmIpfsOptions","fetchTimeout","ipfsGateway","gateway","kernelProxy","Cache","appContextPool","AppContextPool","init","aclAddress","call","_","Error","currentBlock","eth","getBlockNumber","cacheBlockHeight","Math","max","updateInitializationBlock","initAccounts","accounts","initAcl","acl","initIdentityProviders","initApps","initForwarders","initAppIdentifiers","initNetwork","initForwardedActions","initAppMetadata","trigger","Subject","transactions","signatures","fetchFromWeb3","providedAccounts","ReplaySubject","concat","getAccounts","setAccounts","aclProxy","initializationBlock","SET_PERMISSION_EVENT","CHANGE_PERMISSION_MANAGER_EVENT","ACL_CACHE_KEY","cachedAclState","get","permissions","cachedPermissions","blockNumber","cachedBlockNumber","pastEventsOptions","toBlock","fromBlock","undefined","pastEvents$","pastEvents","pipe","event","returnValues","currentEvents$","fetchedPermissions$","eventData","app","appPermissions","key","role","allowedEntitiesSet","Set","dotprop","allowed","add","entity","delete","set","Array","from","manager","connect","cachedPermissions$","isApp","kernelAddress","isKernelAddress","address","applicationInfoCache","AsyncRequestCache","cacheKey","appId","codeAddress","split","fetchLatestRepoContentForContract","resolve","proxyContractValueCache","proxyAddress","Promise","all","then","values","appProxy","appProxyForwarder","catch","isForwarder","installedApps$","keys","oldProxies","newProxies","length","oldSet","intersection","filter","newProxy","has","size","proxyAddresses","appsWithoutKernel","map","proxyValues","request","appProxies","updatedApps$","namespace","updateApps","setAppEvent","apps","setAppId","updated","updatedApps","apps$","appsWithInfo$","appInfo","isForwarderOverride","isArray","abi","some","type","name","installedRepoCache","Map","repo$","reduce","installedRepos","contractAddress","repos","newRepoAppIds","updatedRepoAppIds","forEach","repo","push","newRepos","repoProxy","repoAddress","err","console","error","update$","newRepo$","repoAddress$","version$","initialVersions","versionId","eventVersionId","timestamp","getBlock","versionIndex","findIndex","versionInfo","versions","newVersionInfo","newVersions","repoUpdate","updatedAppId","update","updatedRepoInfo","updatedRepoAppId","installedRepoInfo","latestVersion","currentVersion","reverse","find","version","currentVersionRequest","content","versionInfos","updatedRepo","repoIndex","nextRepos","asyncScheduler","leading","trailing","forwarders","appIdentifiers","BehaviorSubject","identifiers","identifier","cachedMetadata","appMetadata","inMemoryMetadata","dataId","cid","to","mutate","metadataRegistry","registerAppMetadata","next","cachedActions","forwardedActions","inMemoryActions","actionId","currentApp","evmScript","status","target","includes","actions","targetActions","completedActionKeys","failedActionKeys","pendingActionKeys","actionKey","existingAction","statusKey","k","setForwardedAction","decodeTransactionPath","pop","setAppIdentifier","defaultIdentityProviders","LocalIdentityProvider","detectedIdentityProviders","identityProviders","identityProviderRegistrar","identityIntents","modifyAddressIdentity","metadata","providerName","modify","reject","resolveAddressIdentity","searchIdentities","searchTerm","search","requestAddressIdentityModification","removeLocalIdentities","addresses","localProvider","remove","getLocalIdentities","getAll","network","id","net","getId","getNetworkType","requestAppPath","appAddress","path","getApp","pathIntents","setAppPath","triggerAppStore","eventName","origin","frontendEvent","runApp","toPromise","sandboxMessengerProvider","messenger","Messenger","request$","requests","proxy","wrapper","handlerSubscription","handlers","combineRequestHandlers","createRequestHandler","describeScript","describeTransaction","getApps","web3Eth","intent","signMessage","externalCall","externalEvents","externalIntent","externalPastEvents","appIdentifier","addressIdentity","getAppMetadata","queryAppMetadata","updateForwardedAction","getForwardedActions","newTrigger","getTriggers","subscribe","response","sendResponse","payload","shutdown","unsubscribe","shutdownAndClearCache","promise","startsWith","message","requestingApp","performTransactionPath","transactionPath","external","transaction","performACLIntent","method","params","getACLTransactionPath","getTransactionPath","destination","methodName","finalForwarder","account","calculateTransactionPath","describeTransactionPath","getExternalTransactionPath","methodJsonDescription","installedApp","tx","getTransactionPathForIntentBasket","intentBasket","checkMode","intentsToCheck","intentPaths","pathsMatch","sender","directTransactions","decoratedTransactions","applyTransactionGas","createForwarderTransaction","forwarderPath","slice","nextForwarder","lastStep","encodedLastStep","getPermissionManager","roleHash","aclAddr","functionArtifact","functions","sig","roles","methodABI","item","inputNames","inputs","input","appIndex","indexOf","roleIndex","script","segment","data","forwardedEvmScript","children","step","decoratedStep","description","processed","annotatedDescription","canForward","forwarder","Contract","methods","getDefaultGasPrice","gasLimit","isForwarding","pretransaction","estimatedGasLimit","estimateGas","gas","recommendedGasLimit","gasPrice","finalForwarderProvided","directTransaction","appsWithPermissionForMethod","roleSig","bytes","permissionsForDestination","forwardersWithPermission","calculateForwardingPath","transactionWithFee","queue","forwarderWithPermission","nextQueue","shift","previousForwarder"],"mappings":"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","sourcesContent":["// Externals\nimport { asyncScheduler, concat, from, merge, of, BehaviorSubject, ReplaySubject, Subject } from 'rxjs'\nimport {\n  concatMap,\n  debounceTime,\n  distinctUntilChanged,\n  endWith,\n  filter,\n  first,\n  map,\n  mergeAll,\n  mergeMap,\n  publishReplay,\n  scan,\n  startWith,\n  switchMap,\n  throttleTime,\n  withLatestFrom\n} from 'rxjs/operators'\nimport Web3 from 'web3'\nimport { isAddress } from 'web3-utils'\nimport dotprop from 'dot-prop'\n\n// RPC\nimport Messenger from '@aragon/rpc-messenger'\nimport * as handlers from './rpc/handlers'\n\nimport AppContextPool from './apps'\nimport Cache from './cache'\nimport apm, { getApmInternalAppInfo } from './core/apm'\nimport { makeRepoProxy, getAllRepoVersions, getRepoVersionById } from './core/apm/repo'\nimport {\n  getAragonOsInternalAppInfo,\n  isAragonOsInternalApp\n} from './core/aragonOS'\nimport { isKernelAppCodeNamespace } from './core/aragonOS/kernel'\nimport { setConfiguration } from './configuration'\nimport * as configurationKeys from './configuration/keys'\nimport ens from './ens'\nimport { LocalIdentityProvider } from './identity'\nimport { getAbi } from './interfaces'\nimport {\n  postprocessRadspecDescription,\n  tryDescribingUpdateAppIntent,\n  tryDescribingUpgradeOrganizationBasket,\n  tryEvaluatingRadspec\n} from './radspec'\nimport {\n  addressesEqual,\n  getCacheKey,\n  includesAddress,\n  makeAddressMapProxy,\n  makeProxy,\n  makeProxyFromAppABI,\n  AsyncRequestCache\n} from './utils'\nimport { decodeCallScript, encodeCallScript, isCallScript } from './utils/callscript'\nimport { isValidForwardCall, parseForwardCall } from './utils/forwarding'\nimport { doIntentPathsMatch } from './utils/intents'\nimport {\n  applyForwardingPretransaction,\n  createDirectTransaction,\n  createDirectTransactionForApp,\n  createForwarderTransactionBuilder,\n  getRecommendedGasLimit\n} from './utils/transactions'\n\n// matches BLOCK_REORG_MARGIN from aragon-api\nconst REORG_SAFETY_BLOCK_AGE = 100\n\n// Try to get an injected web3 provider, return a public one otherwise.\nexport const detectProvider = () =>\n  typeof web3 !== 'undefined'\n    ? web3.currentProvider // eslint-disable-line\n    : 'wss://rinkeby.eth.aragon.network/ws'\n\n/**\n * An Aragon wrapper.\n *\n * @param {string} daoAddress\n *        The address of the DAO.\n * @param {Object} options\n *        Wrapper options.\n * @param {Object} options.apm\n *        Options for fetching information from aragonPM\n * @param {string} options.apm.ensRegistryAddress\n *        ENS registry for aragonPM\n * @param {Object} [options.apm.ipfs]\n *        IPFS provider config for aragonPM\n * @param {string} [options.apm.ipfs.gateway]\n *        IPFS gateway to fetch aragonPM artifacts from\n * @param {number} [options.apm.ipfs.fetchTimeout]\n *        Timeout for retrieving aragonPM artifacts from IPFS before failing\n * @param {Object} [options.cache]\n *        Options for the internal cache\n * @param {boolean} [options.cache.forceLocalStorage=false]\n *        Downgrade to localStorage even if IndexedDB is available\n * @param {Object} [options.events]\n *        Options for handling Ethereum events\n * @param {boolean} [options.events.subscriptionEventDelay]\n *        Time in ms to delay a new event from a contract subscription\n * @param {Function} [options.defaultGasPriceFn=function]\n *        A factory function to provide the default gas price for transactions.\n *        It can return a promise of number string or a number string. The function\n *        has access to a recommended gas limit which can be used for custom\n *        calculations. This function can also be used to get a good gas price\n *        estimation from a 3rd party resource.\n * @param {string|Object} [options.provider=web3.currentProvider]\n *        The Web3 provider to use for blockchain communication. Defaults to `web3.currentProvider`\n *        if web3 is injected, otherwise will fallback to wss://rinkeby.eth.aragon.network/ws\n */\nexport default class Aragon {\n  constructor (daoAddress, options = {}) {\n    const defaultOptions = {\n      defaultGasPriceFn: () => {},\n      provider: detectProvider(),\n      cache: {\n        forceLocalStorage: false\n      },\n      events: {\n        subscriptionDelayTime: 0\n      }\n    }\n    options = Object.assign(defaultOptions, options)\n\n    // Set up desired configuration\n    setConfiguration(\n      configurationKeys.FORCE_LOCAL_STORAGE,\n      !!(options.cache && options.cache.forceLocalStorage)\n    )\n    setConfiguration(\n      configurationKeys.SUBSCRIPTION_EVENT_DELAY,\n      Number.isFinite(options.events && options.events.subscriptionEventDelay)\n        ? options.events.subscriptionEventDelay\n        : 0\n    )\n\n    // Set up Web3\n    this.web3 = new Web3(options.provider)\n\n    // Set up ENS\n    this.ens = ens(options.provider, options.apm.ensRegistryAddress)\n\n    // Set up APM utilities\n    const { ipfs: apmIpfsOptions = {} } = options.apm\n    this.apm = apm(\n      this.web3,\n      {\n        fetchTimeout: apmIpfsOptions.fetchTimeout,\n        ipfsGateway: apmIpfsOptions.gateway\n      }\n    )\n\n    // Set up the kernel proxy\n    this.kernelProxy = makeProxy(daoAddress, 'Kernel', this.web3)\n\n    // Set up cache\n    this.cache = new Cache(daoAddress)\n\n    // Set up app contexts\n    this.appContextPool = new AppContextPool()\n\n    this.defaultGasPriceFn = options.defaultGasPriceFn\n  }\n\n  /**\n   * Initialise the wrapper.\n   *\n   * @param {Object} [options] Options\n   * @param {Object} [options.accounts] `initAccount()` options (see below)\n   * @param {Object} [options.acl] `initACL()` options (see below)\n   * @return {Promise<void>}\n   * @throws {Error} Will throw an error if the `daoAddress` is detected to not be a Kernel instance\n   */\n  async init (options = {}) {\n    let aclAddress\n\n    try {\n      // Check if address is kernel\n      // web3 throws if it's an empty address ('0x')\n      aclAddress = await this.kernelProxy.call('acl')\n    } catch (_) {\n      throw Error(`Provided daoAddress is not a DAO`)\n    }\n\n    const currentBlock = await this.web3.eth.getBlockNumber()\n    const cacheBlockHeight = Math.max(currentBlock - REORG_SAFETY_BLOCK_AGE, 0) // clamp to 0 for safety\n\n    await this.cache.init()\n    await this.kernelProxy.updateInitializationBlock()\n    await this.initAccounts(options.accounts)\n    await this.initAcl(Object.assign({ aclAddress, cacheBlockHeight }, options.acl))\n    await this.initIdentityProviders()\n    this.initApps()\n    this.initForwarders()\n    this.initAppIdentifiers()\n    this.initNetwork()\n    this.initForwardedActions({ cacheBlockHeight })\n    this.initAppMetadata({ cacheBlockHeight })\n    this.trigger = new Subject()\n    this.transactions = new Subject()\n    this.signatures = new Subject()\n  }\n\n  /**\n   * Initialise the accounts observable.\n   *\n   * @param {Object} [options] Options\n   * @param {boolean} [options.fetchFromWeb3] Whether or not accounts should also be fetched from\n   *                                          the provided Web3 instance\n   * @param {Array<string>} [options.providedAccounts] Array of accounts that the user controls\n   * @return {Promise<void>}\n   */\n  async initAccounts ({ fetchFromWeb3, providedAccounts = [] } = {}) {\n    this.accounts = new ReplaySubject(1)\n    const accounts = fetchFromWeb3\n      ? providedAccounts.concat(await this.web3.eth.getAccounts())\n      : providedAccounts\n\n    this.setAccounts(accounts)\n  }\n\n  /**\n   * Initialise the ACL (Access Control List).\n   *\n   * @return {Promise<void>}\n   */\n  async initAcl ({ aclAddress, cacheBlockHeight } = {}) {\n    if (!aclAddress) {\n      aclAddress = await this.kernelProxy.call('acl')\n    }\n\n    // Set up ACL proxy\n    this.aclProxy = makeProxy(aclAddress, 'ACL', this.web3, { initializationBlock: this.kernelProxy.initializationBlock })\n\n    const SET_PERMISSION_EVENT = 'SetPermission'\n    const CHANGE_PERMISSION_MANAGER_EVENT = 'ChangePermissionManager'\n\n    const ACL_CACHE_KEY = getCacheKey(aclAddress, 'acl')\n\n    // Check if we have cached ACL for this address\n    // Cache object for an ACL: { permissions, blockNumber }\n    const cachedAclState = await this.cache.get(ACL_CACHE_KEY, {})\n    const { permissions: cachedPermissions, blockNumber: cachedBlockNumber } = cachedAclState\n\n    const pastEventsOptions = {\n      toBlock: cacheBlockHeight,\n      // When using cache, fetch events from the next block after cache\n      fromBlock: cachedPermissions ? cachedBlockNumber + 1 : undefined\n    }\n    const pastEvents$ = this.aclProxy.pastEvents(null, pastEventsOptions).pipe(\n      mergeMap((pastEvents) => from(pastEvents)),\n      // Custom cache event\n      endWith({\n        event: ACL_CACHE_KEY,\n        returnValues: {}\n      })\n    )\n    const currentEvents$ = this.aclProxy.events(null, { fromBlock: cacheBlockHeight + 1 }).pipe(\n      startWith({\n        event: 'starting current events',\n        returnValues: {}\n      })\n    )\n\n    // Permissions Object:\n    // { app -> role -> { manager, allowedEntities -> [ entities with permission ] } }\n    const fetchedPermissions$ = concat(pastEvents$, currentEvents$).pipe(\n      scan(([permissions], event) => {\n        const eventData = event.returnValues\n\n        if (eventData.app) {\n          // NOTE: dotprop.get() doesn't work through proxies, so we manually access permissions\n          const appPermissions = permissions[eventData.app] || {}\n\n          if (event.event === SET_PERMISSION_EVENT) {\n            const key = `${eventData.role}.allowedEntities`\n\n            // Converts to and from a set to avoid duplicated entities\n            const allowedEntitiesSet = new Set(dotprop.get(appPermissions, key, []))\n\n            if (eventData.allowed) {\n              allowedEntitiesSet.add(eventData.entity)\n            } else {\n              allowedEntitiesSet.delete(eventData.entity)\n            }\n\n            dotprop.set(appPermissions, key, Array.from(allowedEntitiesSet))\n          }\n\n          if (event.event === CHANGE_PERMISSION_MANAGER_EVENT) {\n            // We only care about the last one. An app permission can have only one manager\n            dotprop.set(appPermissions, `${eventData.role}.manager`, eventData.manager)\n          }\n\n          permissions[eventData.app] = appPermissions\n        }\n\n        return [permissions, event]\n      }, [ makeAddressMapProxy(cachedPermissions || {}) ]),\n\n      // Cache if we're finished syncing up to cache block height\n      map(([permissions, event]) => {\n        if (event.event === ACL_CACHE_KEY) {\n          this.cache.set(\n            ACL_CACHE_KEY,\n            // Make copy for cache\n            { permissions: Object.assign({}, permissions), blockNumber: cacheBlockHeight }\n          )\n        }\n        return permissions\n      }),\n\n      // Throttle so it only continues after 30ms without new values\n      // Avoids DDOSing subscribers as during initialization there may be\n      // hundreds of events processed in a short timespan\n      debounceTime(30),\n      publishReplay(1)\n    )\n    fetchedPermissions$.connect()\n\n    const cachedPermissions$ = cachedPermissions ? of(makeAddressMapProxy(cachedPermissions)) : of()\n    this.permissions = concat(cachedPermissions$, fetchedPermissions$).pipe(publishReplay(1))\n    this.permissions.connect()\n  }\n\n  /**\n   * Check if an object is an app.\n   *\n   * @param  {Object}  app\n   * @return {boolean}\n   */\n  isApp (app) {\n    return app.kernelAddress && this.isKernelAddress(app.kernelAddress)\n  }\n\n  /**\n   * Check if an address is this DAO's kernel.\n   *\n   * @param  {string}  address\n   * @return {boolean}\n   */\n  isKernelAddress (address) {\n    return addressesEqual(address, this.kernelProxy.address)\n  }\n\n  /**\n   * Initialize apps observable.\n   *\n   * @return {void}\n   */\n  initApps () {\n    /******************************\n     *                            *\n     *          CACHING           *\n     *                            *\n     ******************************/\n\n    const applicationInfoCache = new AsyncRequestCache(async (cacheKey) => {\n      const [appId, codeAddress] = cacheKey.split('.')\n      return getAragonOsInternalAppInfo(appId) ||\n        getApmInternalAppInfo(appId) ||\n        this.apm.fetchLatestRepoContentForContract(\n          await this.ens.resolve(appId),\n          codeAddress\n        )\n    })\n\n    const proxyContractValueCache = new AsyncRequestCache((proxyAddress) => {\n      if (this.isKernelAddress(proxyAddress)) {\n        const kernelProxy = makeProxy(proxyAddress, 'ERCProxy', this.web3)\n\n        return Promise.all([\n          // Use Kernel ABI\n          this.kernelProxy.call('KERNEL_APP_ID'),\n          // Use ERC897 proxy ABI\n          // Note that this won't work on old Aragon Core 0.5 Kernels,\n          // as they had not implemented ERC897 yet\n          kernelProxy.call('implementation')\n        ]).then((values) => ({\n          appId: values[0],\n          codeAddress: values[1]\n        }))\n      }\n\n      const appProxy = makeProxy(proxyAddress, 'AppProxy', this.web3)\n      const appProxyForwarder = makeProxy(proxyAddress, 'Forwarder', this.web3)\n\n      return Promise.all([\n        appProxy.call('kernel'),\n        appProxy.call('appId'),\n        appProxy.call('implementation'),\n        // Not all apps implement the forwarding interface\n        appProxyForwarder.call('isForwarder').catch(() => false)\n      ]).then((values) => ({\n        kernelAddress: values[0],\n        appId: values[1],\n        codeAddress: values[2],\n        isForwarder: values[3]\n      }))\n    })\n\n    /******************************\n     *                            *\n     *            APPS            *\n     *                            *\n     ******************************/\n\n    // Get all installed app proxy addresses\n    const installedApps$ = this.permissions.pipe(\n      map(Object.keys),\n      // Dedupe until apps change\n      distinctUntilChanged((oldProxies, newProxies) => {\n        if (oldProxies.length !== newProxies.length) {\n          return false\n        }\n        const oldSet = new Set(oldProxies)\n        const intersection = new Set(newProxies.filter(newProxy => oldSet.has(newProxy)))\n        return intersection.size === oldSet.size\n      }),\n      // Add Kernel as the first \"app\"\n      map((proxyAddresses) => {\n        const appsWithoutKernel = proxyAddresses.filter((address) => !this.isKernelAddress(address))\n        return [this.kernelProxy.address].concat(appsWithoutKernel)\n      }),\n      // Get proxy values\n      // Note that we can safely discard throttled values,\n      // so we use a `switchMap()` instead of a `mergeMap()`\n      switchMap(\n        (proxyAddresses) => Promise.all(\n          proxyAddresses.map(async (proxyAddress) => {\n            let proxyValues\n            try {\n              proxyValues = await proxyContractValueCache.request(proxyAddress)\n            } catch (_) {}\n\n            return {\n              proxyAddress,\n              ...proxyValues\n            }\n          })\n        )\n      ),\n      // Filter to remove any non-apps assigned in permissions\n      map(appProxies => appProxies.filter(\n        (appProxy) => this.isApp(appProxy) || this.isKernelAddress(appProxy.proxyAddress)\n      ))\n    )\n\n    // SetApp events are emitted when apps are installed and upgraded\n    // These may modify the implementation addresses of the proxies (modifying their behaviour), so\n    // we invalidate any caching we've done\n    const updatedApps$ = this.kernelProxy\n      // Only need to subscribe from latest block\n      .events('SetApp', { fromBlock: 'latest' })\n      .pipe(\n        // Only care about changes if they're in the APP_BASE namespace\n        filter(({ returnValues }) => isKernelAppCodeNamespace(returnValues.namespace)),\n\n        // Merge with latest value of installedApps$ so we can return the full list of apps\n        withLatestFrom(\n          installedApps$,\n          function updateApps (setAppEvent, apps) {\n            const { appId: setAppId } = setAppEvent.returnValues\n            return apps.map(async (app) => {\n              if (app.appId !== setAppId) {\n                return app\n              }\n\n              let proxyValues\n              try {\n                proxyValues = await proxyContractValueCache.request(\n                  app.proxyAddress,\n                  true // force cache invalidation\n                )\n              } catch (_) {}\n\n              return {\n                ...app,\n                ...proxyValues,\n                updated: true\n              }\n            })\n          }\n        ),\n        // Emit resolved array of promises, one at a time\n        concatMap(updatedApps => Promise.all(updatedApps))\n      )\n\n    // We merge these two observables, which both return the full list of apps attached with their\n    // proxy values:\n    //   - installedApps$: emits any time the list of installed apps changes\n    //   - updatedApps$:   emits any time SetApp could modify an installed app\n    const apps$ = merge(installedApps$, updatedApps$)\n\n    // Get artifact info for apps\n    const appsWithInfo$ = apps$.pipe(\n      concatMap(\n        (apps) => Promise.all(\n          apps.map(async (app) => {\n            let appInfo\n            if (app.appId && app.codeAddress) {\n              const cacheKey = `${app.appId}.${app.codeAddress}`\n              try {\n                appInfo = await applicationInfoCache.request(cacheKey)\n              } catch (_) { }\n            }\n\n            // This is a hack to fix web3.js and ethers not being able to detect reverts on decoding\n            // `eth_call`s (apps that implement fallbacks may revert if they haven't defined\n            // `isForwarder()`)\n            // Ideally web3.js would throw an error if it receives a revert from an `eth_call`, but\n            // as of v1.2.1, it interprets reverts as `true` :(.\n            //\n            // We check if the app's ABI actually has `isForwarder()` declared, and if not, override\n            // the isForwarder setting to false.\n            let isForwarderOverride = {}\n            if (\n              app.isForwarder &&\n              appInfo &&\n              Array.isArray(appInfo.abi) &&\n              !appInfo.abi.some(({ type, name }) => type === 'function' && name === 'isForwarder')\n            ) {\n              isForwarderOverride = {\n                isForwarder: false\n              }\n            }\n\n            return {\n              ...appInfo,\n              // Override the fetched appInfo with the actual app proxy's values to avoid mismatches\n              ...app,\n              // isForwarder override (see above)\n              ...isForwarderOverride\n            }\n          })\n        )\n      )\n    )\n\n    this.apps = appsWithInfo$.pipe(\n      publishReplay(1)\n    )\n    this.apps.connect()\n\n    /*******************************\n     *                             *\n     *            REPOS            *\n     *                             *\n     ******************************/\n\n    // Initialize installed repos from the list of apps\n    const installedRepoCache = new Map()\n    const repo$ = apps$.pipe(\n      // Map installed apps into a deduped list of their aragonPM repos, with these assumptions:\n      //   - No apps are lying about their appId (malicious apps _could_ masquerade as other\n      //     apps by setting this value themselves)\n      //   - `contractAddress`s will stay the same across all installed apps.\n      //     This is technically not true as apps could set this value themselves\n      //     (e.g. as pinned apps do), but these apps wouldn't be able to upgrade anyway\n      //\n      //  Ultimately returns an array of objects, holding the repo's:\n      //    - appId\n      //    - base contractAddress\n      map((apps) => Object.values(\n        apps\n          .filter(({ appId }) => !isAragonOsInternalApp(appId))\n          .reduce((installedRepos, { appId, codeAddress, updated }) => {\n            installedRepos[appId] = {\n              appId,\n              updated,\n              contractAddress: codeAddress\n            }\n            return installedRepos\n          }, {})\n      )),\n\n      // Filter list of installed repos into:\n      //   - New repos we haven't seen before (to begin subscribing to their version events)\n      //   - Repos we've seen before, to trigger a recalculation of the currently installed version\n      map((repos) => {\n        const newRepoAppIds = []\n        const updatedRepoAppIds = []\n\n        repos.forEach((repo) => {\n          const { appId, updated } = repo\n          if (!installedRepoCache.has(appId)) {\n            newRepoAppIds.push(appId)\n          } else if (updated) {\n            updatedRepoAppIds.push(appId)\n          }\n\n          // Mark repo as seen and cache installed information\n          installedRepoCache.set(appId, repo)\n        })\n\n        return [newRepoAppIds, updatedRepoAppIds]\n      }),\n\n      // Stop if there's no new repos or updated apps\n      filter(([newRepoAppIds, updatedRepoAppIds]) =>\n        newRepoAppIds.length || updatedRepoAppIds.length\n      ),\n\n      // Project new repos into their ids and web3 proxy objects\n      concatMap(async ([newRepoAppIds, updatedRepoAppIds]) => {\n        const newRepos = (await Promise.all(\n          newRepoAppIds.map(async (appId) => {\n            let repoProxy\n\n            try {\n              const repoAddress = await this.ens.resolve(appId)\n              repoProxy = makeRepoProxy(repoAddress, this.web3)\n              await repoProxy.updateInitializationBlock()\n            } catch (err) {\n              console.error(`Could not find repo for ${appId}`, err)\n            }\n\n            return {\n              appId,\n              repoProxy\n            }\n          })\n        ))\n          // Filter out repos we couldn't create proxies for (they were likely due to publishing\n          // invalid aragonPM repos)\n          // Note that we don't need to worry about doing this for the updated repos list; if\n          // we could not create the original repo proxy when we first saw the repo, the updates\n          // won't do anything because we weren't able to fetch enough information (versions list)\n          .filter((newRepos) => newRepos.repoProxy)\n        return [newRepos, updatedRepoAppIds]\n      }),\n\n      // Here's where the fun begins!\n      // It'll be easy to get lost, so remember to take it slowly.\n      // Just remember, with this `mergeMap()`, we'll be subscribing to all the projected (returned)\n      // observables and merging their respective emissions into a single observable.\n      //\n      // The output of this merged observable are update events containing the following:\n      //   - `appId`: mandatory, signifies which repo was updated\n      //   - `repoAddress`: optional, address of the repo contract itself\n      //   - `versions`: optional, new version information\n      mergeMap(([newRepos, updatedRepoAppIds]) => {\n        // Create a new observable to project each new update as its own update emission.\n        const update$ = of(...updatedRepoAppIds).pipe(\n          map((appId) => ({ appId }))\n        )\n\n        // Create a new observable to project each new repo as its own emission.\n        const newRepo$ = of(...newRepos)\n\n        // Create a new observable to project each new repo's address as its own update emission.\n        const repoAddress$ = newRepo$.pipe(\n          map(({ appId, repoProxy }) => ({\n            appId,\n            repoAddress: repoProxy.address\n          }))\n        )\n\n        // Create a new observable that projects each NewVersion event as its own update event\n        // emission.\n        // This one is a bit trickier, due to the higher order observable. Keep reading.\n        const version$ = newRepo$.pipe(\n          // `mergeMap()` to \"flatten\" the async transformation. This async function returns an\n          // observable, which is ultimately the NewVersion stream. More on this, after the break.\n          // Note: we don't care about the ordering, so we use `mergeMap()` instead of `concatMap()`\n          mergeMap(async ({ appId, repoProxy }) => {\n            const initialVersions = [\n              // Immediately query state from the repo contract, to avoid having to wait until all\n              // past events sync (may be long)\n              ...await getAllRepoVersions(repoProxy)\n            ]\n\n            // Return an observable subscribed to NewVersion events, giving us:\n            //   - Timestamps for versions that were published prior to this process running\n            //   - Notifications for newly published versions\n            //\n            // Reduce this with the cached version information to emit version updates for the repo.\n            return repoProxy.events('NewVersion').pipe(\n              // Project each event to a new version info object, one at a time\n              concatMap(async (event) => {\n                const { versionId: eventVersionId } = event.returnValues\n\n                // Adjust from Ethereum time\n                const timestamp = (await this.web3.eth.getBlock(event.blockNumber)).timestamp * 1000\n\n                const versionIndex = initialVersions.findIndex(({ versionId }) => versionId === eventVersionId)\n                const versionInfo =\n                  versionIndex === -1\n                    ? await getRepoVersionById(repoProxy, eventVersionId)\n                    : initialVersions[versionIndex]\n\n                return {\n                  ...versionInfo,\n                  timestamp\n                }\n              }),\n\n              // Trick to immediately emit (e.g. similar to a do/while loop)\n              startWith(null),\n\n              // Reduce newly emitted versions into the full list of versions\n              scan(({ appId, versions }, newVersionInfo) => {\n                let newVersions = versions\n                if (newVersionInfo) {\n                  const versionIndex = versions.findIndex(({ versionId }) => versionId === newVersionInfo.versionId)\n\n                  if (versionIndex === -1) {\n                    newVersions = versions.concat(newVersionInfo)\n                  } else {\n                    newVersions = Array.from(versions)\n                    newVersions[versionIndex] = newVersionInfo\n                  }\n                }\n\n                return {\n                  appId,\n                  versions: newVersions\n                }\n              }, {\n                appId,\n                versions: initialVersions\n              })\n            )\n          }),\n\n          // This bit is interesting.\n          // We've \"flattened\" our async transformation with the `mergeMap()` above, but it still\n          // returns an observable. We need to flatten this observable's emissions into the upper\n          // stream, which is what `mergeAll()` achieves.\n          mergeAll()\n        )\n\n        // Merge all of the repo update events resulting from the apps being updated, and return it\n        // to the upper `mergeMap()` so it can be re-flattened into a single event stream.\n        return merge(repoAddress$, version$, update$)\n      }),\n\n      // Reduce the event stream into a current representation of the installed repos, and which\n      // repo to update next.\n      scan(({ repos }, repoUpdate) => {\n        const { appId: updatedAppId, ...update } = repoUpdate\n        const updatedRepoInfo = {\n          ...repos[updatedAppId],\n          ...update\n        }\n\n        return {\n          repos: {\n            ...repos,\n            [updatedAppId]: updatedRepoInfo\n          },\n          updatedRepoAppId: updatedAppId\n        }\n      }, {\n        repos: {},\n        updatedRepoAppId: null\n      }),\n\n      // Stop if we don't have enough information yet to continue\n      filter(({ repos, updatedRepoAppId }) =>\n        !!updatedRepoAppId && Array.isArray(repos[updatedRepoAppId].versions)\n      ),\n\n      // Grab the full information of the updated repo using its latest values.\n      // With this, we've taken the basic stream of updates for events and mapped them onto their\n      // full repo objects.\n      concatMap(async ({ repos, updatedRepoAppId: appId }) => {\n        const { repoAddress, versions } = repos[appId]\n        const installedRepoInfo = installedRepoCache.get(appId)\n\n        const latestVersion = versions[versions.length - 1]\n        const currentVersion = Array.from(versions)\n          // Apply reverse to find the latest version with the currently installed contract address\n          .reverse()\n          .find(version => version.contractAddress === installedRepoInfo.contractAddress)\n\n        // Get info for the current and latest versions of the repo\n        const currentVersionRequest = applicationInfoCache\n          .request(`${appId}.${currentVersion.contractAddress}`)\n          .catch(() => ({}))\n          .then(content => ({\n            content,\n            version: currentVersion.version\n          }))\n\n        const versionInfos = await Promise.all([\n          currentVersionRequest,\n          currentVersion.contractAddress === latestVersion.contractAddress\n            ? currentVersionRequest // current version is also the latest, no need to refetch\n            : applicationInfoCache\n              .request(`${appId}.${latestVersion.contractAddress}`)\n              .catch(() => ({}))\n              .then(content => ({\n                content,\n                version: latestVersion.version\n              }))\n        ])\n\n        // Emit updated repo information\n        return {\n          appId,\n          repoAddress,\n          versions,\n          currentVersion: versionInfos[0],\n          latestVersion: versionInfos[1]\n        }\n      })\n    )\n\n    this.installedRepos = repo$.pipe(\n      // Finally, we reduce the merged updates from individual repos into one final, expanding array\n      // of the installed repos\n      scan((repos, updatedRepo) => {\n        const repoIndex = repos.findIndex(repo => repo.repoAddress === updatedRepo.repoAddress)\n        if (repoIndex === -1) {\n          return repos.concat(updatedRepo)\n        } else {\n          const nextRepos = Array.from(repos)\n          nextRepos[repoIndex] = updatedRepo\n          return nextRepos\n        }\n      }, []),\n      // Throttle updates, but must keep trailing to ensure we don't drop any updates\n      throttleTime(500, asyncScheduler, { leading: false, trailing: true }),\n      publishReplay(1)\n    )\n    this.installedRepos.connect()\n  }\n\n  /**\n   * Initialise forwarder observable.\n   *\n   * @return {void}\n   */\n  initForwarders () {\n    this.forwarders = this.apps.pipe(\n      map(\n        (apps) => apps.filter((app) => app.isForwarder)\n      ),\n      publishReplay(1)\n    )\n    this.forwarders.connect()\n  }\n\n  /**\n   * Initialise app identifier observable.\n   *\n   * @return {void}\n   */\n  initAppIdentifiers () {\n    this.appIdentifiers = new BehaviorSubject({}).pipe(\n      scan(\n        (identifiers, { address, identifier }) =>\n          Object.assign(identifiers, { [address]: identifier })\n      ),\n      publishReplay(1)\n    )\n    this.appIdentifiers.connect()\n  }\n\n  /**\n   * Initialize the appMetadata observable\n   */\n  async initAppMetadata ({ cacheBlockHeight = 0 } = {}) {\n    const cachedMetadata = (await this.cache.get('appMetadata')) || {}\n    this.appMetadata = new BehaviorSubject({ ...cachedMetadata }).pipe(\n      scan((inMemoryMetadata, { from, blockNumber, dataId, cid, to }) => {\n        function mutate (metadataRegistry) {\n          const key = `${from},${dataId}`\n          if (from) {\n            metadataRegistry[key] = {\n              from,\n              dataId,\n              cid,\n              to\n            }\n          }\n        }\n\n        if (blockNumber < cacheBlockHeight) {\n          mutate(cachedMetadata)\n          this.cache.set('appMetadata', cachedMetadata)\n        }\n        mutate(inMemoryMetadata)\n        return inMemoryMetadata\n      }),\n      publishReplay(1)\n    )\n    this.appMetadata.connect()\n  }\n\n  /**\n   * registers new app metadata item\n   *\n   * @param {string} from Address of the application generating the data\n   * @param {string} blockNumber block that trigger the metadata creation or update\n   * @param {string} dataId internal ID assigned to the data by the originator (could be actionId)\n   * @param {string} cid external identifier (e.g., IPFS hash)\n   * @param {<Array>string} to Optional list of addresses of the applications intended access to the data, defaults to '*'\n   */\n  registerAppMetadata (from, blockNumber, dataId, cid, to = ['*']) {\n    this.appMetadata.next({\n      from,\n      blockNumber,\n      dataId,\n      cid,\n      to\n    })\n  }\n  /**\n   * Initialize the forwardedActions observable\n   *\n   * @return {void}\n   */\n  async initForwardedActions ({ cacheBlockHeight = 0 } = {}) {\n    const cachedActions = (await this.cache.get('forwardedActions')) || {}\n\n    this.forwardedActions = new BehaviorSubject({ ...cachedActions }).pipe(\n      scan((\n        inMemoryActions,\n        {\n          actionId,\n          blockNumber,\n          currentApp,\n          evmScript,\n          status = 'pending',\n          target\n        }\n      ) => {\n        if (\n          (!currentApp && !actionId && !evmScript && !target) ||\n          !['pending', 'failed', 'completed'].includes(status) ||\n          !blockNumber ||\n          !target\n        ) return inMemoryActions\n\n        function mutate (actions) {\n          const targetActions = actions[target] || {\n            completedActionKeys: [],\n            failedActionKeys: [],\n            pendingActionKeys: [],\n            actions: {}\n          }\n\n          const actionKey = `${currentApp},${actionId}`\n          const existingAction = targetActions.actions[actionKey]\n\n          // dealing with async:\n          // return early if existing action is already marked as completed or failed\n          // (if we already discovered that this action has completed or failed,\n          // we don't want to go back to pending, and there's nothing else to update)\n          if (existingAction && ['failed', 'completed'].includes(existingAction.status)) return\n\n          actions[target] = actions[target] || targetActions\n\n          actions[target].actions[actionKey] = { actionId, currentApp, evmScript, status, target }\n\n          if (!existingAction) {\n            const statusKey = `${status}ActionKeys`\n            actions[target][statusKey] = [ ...targetActions[statusKey], actionKey ]\n          } else {\n            if (status !== 'pending') {\n              actions[target].pendingActionKeys = targetActions.pendingActionKeys.filter(k => k !== actionKey)\n            }\n\n            if (status === 'failed') {\n              actions[target].failedActionKeys = [ ...targetActions.failedActionKeys, actionKey ]\n            }\n\n            if (status === 'completed') {\n              actions[target].completedActionKeys = [ ...targetActions.completedActionKeys, actionKey ]\n            }\n          }\n        }\n\n        if (blockNumber < cacheBlockHeight) {\n          mutate(cachedActions)\n          this.cache.set('forwardedActions', cachedActions)\n        }\n\n        mutate(inMemoryActions)\n        return inMemoryActions\n      }),\n      publishReplay(1)\n    )\n    this.forwardedActions.connect()\n  }\n\n  /**\n   * set a forwarded action\n   *\n   * @param {string} currentApp\n   * @param {string} actionId\n   * @param {string} evmScript\n   * @param {integer} status\n   */\n  setForwardedAction ({\n    actionId,\n    blockNumber,\n    currentApp,\n    evmScript,\n    status = 'pending'\n  }) {\n    if (!blockNumber) throw new Error('must provide blockNumber')\n\n    if (!(['pending', 'failed', 'completed'].includes(status))) {\n      throw new Error(\n        `unexpected status for forwardedAction\n         expected one of 'pending', 'failed', 'completed'\n         got: '${status}'`\n      )\n    }\n\n    if (!evmScript) {\n      throw new Error(\n        `must provide a valid evmScript when forwarding an action;\n         got: '${evmScript}'`\n      )\n    }\n\n    // set the last address as the target of the forwarded action\n    const target = this.decodeTransactionPath(evmScript).pop().to\n\n    this.forwardedActions.next({\n      actionId,\n      blockNumber,\n      currentApp,\n      evmScript,\n      status,\n      target\n    })\n  }\n\n  /**\n   * Set the identifier of an app.\n   *\n   * @param {string} address The proxy address of the app\n   * @param {string} identifier The identifier of the app\n   * @return {void}\n   */\n  setAppIdentifier (address, identifier) {\n    this.appIdentifiers.next({\n      address,\n      identifier\n    })\n  }\n\n  /**\n   * Initialise identity providers.\n   *\n   * @return {Promise<void>}\n   */\n  async initIdentityProviders () {\n    const defaultIdentityProviders = [{\n      name: 'local',\n      provider: new LocalIdentityProvider()\n    }]\n    // TODO: detect other installed providers\n    const detectedIdentityProviders = []\n    const identityProviders = [...defaultIdentityProviders, ...detectedIdentityProviders]\n\n    // Init all providers\n    await Promise.all(identityProviders.map(({ provider }) => {\n      // Most providers should have this defined to a noop function by default, but just in case\n      if (typeof provider.init === 'function') {\n        return provider.init()\n      }\n      return Promise.resolve()\n    }))\n\n    this.identityProviderRegistrar = new Map(\n      identityProviders.map(({ name, provider }) => [name, provider])\n    )\n    // Set up identity modification intent observable\n    this.identityIntents = new Subject()\n  }\n\n  /**\n   * Modify the identity metadata for an address using the highest priority provider.\n   *\n   * @param  {string} address Address to modify\n   * @param  {Object} metadata Modification metadata object\n   * @return {Promise} Resolves if the modification was successful\n   */\n  modifyAddressIdentity (address, metadata) {\n    const providerName = 'local'\n    const provider = this.identityProviderRegistrar.get(providerName)\n    if (provider && typeof provider.modify === 'function') {\n      return provider.modify(address, metadata)\n    }\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Resolve the identity metadata for an address using the highest priority provider.\n   *\n   * @param  {string} address Address to resolve\n   * @return {Promise} Resolves with the identity or null if not found\n   */\n  resolveAddressIdentity (address) {\n    const providerName = 'local' // TODO - get provider\n    const provider = this.identityProviderRegistrar.get(providerName)\n    if (provider && typeof provider.resolve === 'function') {\n      return provider.resolve(address)\n    }\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Search identities based on a term\n   *\n   * @param  {string} searchTerm\n   * @return {Promise} Resolves with the identity or null if not found\n   */\n  searchIdentities (searchTerm) {\n    const providerName = 'local' // TODO - get provider\n    const provider = this.identityProviderRegistrar.get(providerName)\n    if (provider && typeof provider.search === 'function') {\n      return provider.search(searchTerm)\n    }\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Request an identity modification using the highest priority provider.\n   *\n   * Returns a promise which delegates resolution to the handler\n   * which listens and handles `this.identityIntents`\n   *\n   * @param  {string} address Address to modify\n   * @return {Promise} Resolved by the handler of identityIntents\n   */\n  requestAddressIdentityModification (address) {\n    const providerName = 'local' // TODO - get provider\n    if (this.identityProviderRegistrar.has(providerName)) {\n      return new Promise((resolve, reject) => {\n        this.identityIntents.next({\n          address,\n          providerName,\n          resolve,\n          reject (err) {\n            reject(err || new Error('The identity modification was not completed'))\n          }\n        })\n      })\n    }\n\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Remove selected local identities\n   *\n   * @param {Array<string>} addresses The addresses to be removed from the local identity provider\n   * @return {Promise}\n   */\n  async removeLocalIdentities (addresses) {\n    const localProvider = this.identityProviderRegistrar.get('local')\n    for (const address of addresses) {\n      await localProvider.remove(address)\n    }\n  }\n\n  /**\n   * Get all local identities for listing functionality\n   *\n   * @return {Promise<Object>}\n   */\n  getLocalIdentities () {\n    return this.identityProviderRegistrar.get('local').getAll()\n  }\n\n  /**\n   * Initialise the network observable.\n   *\n   * @return {Promise<void>}\n   */\n  async initNetwork () {\n    this.network = new ReplaySubject(1)\n    this.network.next({\n      id: await this.web3.eth.net.getId(),\n      type: await this.web3.eth.net.getNetworkType()\n    })\n  }\n\n  /**\n   * Request an app's path be changed.\n   *\n   * @param {string} appAddress\n   * @param {string} path\n   * @return {Promise} Succeeds if path request was allowed\n   */\n  async requestAppPath (appAddress, path) {\n    if (typeof path !== 'string') {\n      throw new Error('Path must be a string')\n    }\n\n    if (!await this.getApp(appAddress)) {\n      throw new Error(`Cannot request path for non-installed app: ${appAddress}`)\n    }\n\n    return new Promise((resolve, reject) => {\n      this.pathIntents.next({\n        appAddress,\n        path,\n        resolve,\n        reject (err) {\n          reject(err || new Error('The path was rejected'))\n        }\n      })\n    })\n  }\n\n  /**\n   * Set an app's path.\n   *\n   * @param {string} appAddress\n   * @param {string} path\n   * @return {void}\n   */\n  setAppPath (appAddress, path) {\n    if (typeof path !== 'string') {\n      throw new Error('Path must be a string')\n    }\n\n    this.appContextPool.set(appAddress, 'path', path)\n  }\n\n  /**\n   *\n   * Emit an event with returnValues in the appProxy's store\n   *\n   * @param {string} appProxy the app context where the event will be emitted\n   * @param {string} eventName The name of the event to be handled within the `store`\n   * @param {Object} returnValues Optional returnValues passed within the event\n   * @return {void}\n   */\n  triggerAppStore (appProxy, eventName, returnValues) {\n    this.trigger.next({\n      origin: appProxy,\n      frontendEvent: {\n        event: eventName,\n        returnValues\n      }\n    })\n  }\n\n  /**\n   * Run an app.\n   *\n   * As there may be race conditions with losing messages from cross-context environments,\n   * running an app is split up into two parts:\n   *\n   *   1. Set up any required state for the app. This step is allowed to be asynchronous.\n   *   2. Connect the app to a running context, by associating the context's message provider\n   *      to the app. This step is synchronous.\n   *\n   * @param  {string} proxyAddress\n   *         The address of the app proxy.\n   * @return {Promise<function>}\n   */\n  async runApp (proxyAddress) {\n    // Step 1: Set up required state for the app\n\n    // Only get the first result from the observable, so our running contexts don't get\n    // reinitialized if new apps appear\n    const apps = await this.apps.pipe(first()).toPromise()\n\n    const app = apps.find((app) => addressesEqual(app.proxyAddress, proxyAddress))\n\n    // TODO: handle undefined (no proxy found), otherwise when calling app.proxyAddress next, it will throw\n    const appProxy = makeProxyFromAppABI(app.proxyAddress, app.abi, this.web3)\n\n    await appProxy.updateInitializationBlock()\n\n    // Step 2: Associate app with running context\n    return (sandboxMessengerProvider) => {\n      // Set up messenger\n      const messenger = new Messenger(\n        sandboxMessengerProvider\n      )\n\n      // Wrap requests with the application proxy\n      // Note that we have to do this synchronously with the creation of the message provider,\n      // as we otherwise risk race conditions and may lose messages\n      const request$ = messenger.requests().pipe(\n        map(request => ({ request, proxy: appProxy, wrapper: this })),\n        // Use the same request$ result in each handler\n        // Turns request$ into a subject\n        publishReplay(1)\n      )\n      request$.connect()\n\n      // Register request handlers\n      const handlerSubscription = handlers.combineRequestHandlers(\n        // Generic handlers\n        handlers.createRequestHandler(request$, 'accounts', handlers.accounts),\n        handlers.createRequestHandler(request$, 'cache', handlers.cache),\n        handlers.createRequestHandler(request$, 'describe_script', handlers.describeScript),\n        handlers.createRequestHandler(request$, 'describe_transaction', handlers.describeTransaction),\n        handlers.createRequestHandler(request$, 'get_apps', handlers.getApps),\n        handlers.createRequestHandler(request$, 'network', handlers.network),\n        handlers.createRequestHandler(request$, 'path', handlers.path),\n        handlers.createRequestHandler(request$, 'web3_eth', handlers.web3Eth),\n\n        // Contract handlers\n        handlers.createRequestHandler(request$, 'intent', handlers.intent),\n        handlers.createRequestHandler(request$, 'call', handlers.call),\n        handlers.createRequestHandler(request$, 'sign_message', handlers.signMessage),\n        handlers.createRequestHandler(request$, 'events', handlers.events),\n        handlers.createRequestHandler(request$, 'past_events', handlers.pastEvents),\n\n        // External contract handlers\n        handlers.createRequestHandler(request$, 'external_call', handlers.externalCall),\n        handlers.createRequestHandler(request$, 'external_events', handlers.externalEvents),\n        handlers.createRequestHandler(request$, 'external_intent', handlers.externalIntent),\n        handlers.createRequestHandler(request$, 'external_past_events', handlers.externalPastEvents),\n\n        // Identity handlers\n        handlers.createRequestHandler(request$, 'identify', handlers.appIdentifier),\n        handlers.createRequestHandler(request$, 'address_identity', handlers.addressIdentity),\n        handlers.createRequestHandler(request$, 'search_identities', handlers.searchIdentities),\n\n        // Cross-app handlers\n        handlers.createRequestHandler(request$, 'register_app_metadata', handlers.registerAppMetadata),\n        handlers.createRequestHandler(request$, 'get_app_metadata', handlers.getAppMetadata),\n        handlers.createRequestHandler(request$, 'query_app_metadata', handlers.queryAppMetadata),\n        handlers.createRequestHandler(request$, 'update_forwarded_action', handlers.updateForwardedAction),\n        handlers.createRequestHandler(request$, 'get_forwarded_actions', handlers.getForwardedActions),\n\n        // Etc.\n        handlers.createRequestHandler(request$, 'trigger', handlers.newTrigger),\n        handlers.createRequestHandler(request$, 'getTriggers', handlers.getTriggers)\n      ).subscribe(\n        (response) => messenger.sendResponse(response.id, response.payload)\n      )\n\n      // The attached unsubscribe isn't automatically bound to the subscription\n      const shutdown = () => handlerSubscription.unsubscribe()\n\n      const shutdownAndClearCache = async () => {\n        shutdown()\n\n        // Remove all cache keys related to this app one by one\n        return Object\n          .keys(await this.cache.getAll())\n          .reduce((promise, cacheKey) => {\n            return promise.then(() =>\n              cacheKey.startsWith(proxyAddress)\n                ? this.cache.remove(cacheKey)\n                : Promise.resolve()\n            )\n          }, Promise.resolve())\n      }\n\n      return {\n        shutdown,\n        shutdownAndClearCache\n      }\n    }\n  }\n\n  /**\n   * Set the available accounts for the current user.\n   *\n   * @param {Array<string>} accounts\n   * @return {void}\n   */\n  setAccounts (accounts) {\n    this.accounts.next(accounts)\n  }\n\n  /**\n   * Get the available accounts for the current user.\n   *\n   * @return {Promise<Array<string>>} An array of addresses\n   */\n  getAccounts () {\n    return this.accounts.pipe(first()).toPromise()\n  }\n\n  /**\n   * Allows apps to sign arbitrary data via a RPC call\n   *\n   * @param {string} message to be signed\n   * @param {string} requestingApp proxy address of requesting app\n   * @return {Promise<string>} signature hash\n   */\n  signMessage (message, requestingApp) {\n    if (typeof message !== 'string') {\n      return Promise.reject(new Error('Message to sign must be a string'))\n    }\n    return new Promise((resolve, reject) => {\n      this.signatures.next({\n        message,\n        requestingApp,\n        resolve,\n        reject (err) {\n          reject(err || new Error('The message was not signed'))\n        }\n      })\n    })\n  }\n\n  /**\n   * @param {Array<Object>} transactionPath An array of Ethereum transactions that describe each\n   *   step in the path\n   * @param {Object} [options]\n   * @param {boolean} [options.external] Whether the transaction path is initiating an action on\n   *   an external destination (not the currently running app)\n   * @return {Promise<string>} Promise that should be resolved with the sent transaction hash\n   */\n  performTransactionPath (transactionPath, { external } = {}) {\n    return new Promise((resolve, reject) => {\n      this.transactions.next({\n        resolve,\n        external: !!external,\n        transaction: transactionPath[0],\n        path: transactionPath,\n        reject (err) {\n          reject(err || new Error('The transaction was not signed'))\n        }\n      })\n    })\n  }\n\n  /**\n   * Performs an action on the ACL using transaction pathing\n   *\n   * @param {string} method\n   * @param {Array<*>} params\n   * @return {Promise<string>} transaction hash\n   */\n  async performACLIntent (method, params) {\n    const path = await this.getACLTransactionPath(method, params)\n    return this.performTransactionPath(path)\n  }\n\n  /**\n   * Looks for app with the provided proxyAddress and returns its app object if found\n   *\n   * @param {string} proxyAddress\n   * @return {Promise<Object>} The app object\n   */\n  getApp (proxyAddress) {\n    return this.apps.pipe(\n      map(apps => apps.find(app => addressesEqual(app.proxyAddress, proxyAddress))),\n      first()\n    ).toPromise()\n  }\n\n  /**\n   * Calculate the transaction path for a transaction to `destination`\n   * that invokes `methodName` with `params`.\n   *\n   * @param  {string} destination\n   * @param  {string} methodName\n   * @param  {Array<*>} params\n   * @param  {string} [finalForwarder] Address of the final forwarder that can perfom the action\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path\n   */\n  async getTransactionPath (destination, methodName, params, finalForwarder) {\n    const accounts = await this.getAccounts()\n\n    for (let account of accounts) {\n      const path = await this.calculateTransactionPath(\n        account,\n        destination,\n        methodName,\n        params,\n        finalForwarder\n      )\n\n      if (path.length > 0) {\n        try {\n          return this.describeTransactionPath(path)\n        } catch (_) {\n          return path\n        }\n      }\n    }\n\n    return []\n  }\n\n  /**\n   * Calculate the transaction path for a transaction to an external `destination`\n   * (not the currently running app) that invokes a method matching the\n   * `methodJsonDescription` with `params`.\n   *\n   * @param  {string} destination Address of the external contract\n   * @param  {object} methodJsonDescription ABI description of method to invoke\n   * @param  {Array<*>} params\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path.\n   *   If the destination is a non-installed contract, always results in an array containing a\n   *   single transaction.\n   */\n  async getExternalTransactionPath (destination, methodJsonDescription, params) {\n    let path\n\n    const installedApp = await this.getApp(destination)\n    if (installedApp) {\n      // Destination is an installed app; need to go through normal transaction pathing\n      path = this.getTransactionPath(destination, methodJsonDescription.name, params)\n    } else {\n      // Destination is not an installed app on this org, just create a direct transaction\n      // with the first account\n      const account = (await this.getAccounts())[0]\n\n      try {\n        const tx = await createDirectTransaction(account, destination, methodJsonDescription, params, this.web3)\n        path = this.describeTransactionPath([tx])\n      } catch (_) {}\n    }\n\n    return path || []\n  }\n\n  /**\n   * Calculate the transaction path for a basket of intents.\n   * Expects the `intentBasket` to be an array of tuples holding the following:\n   *   {string}   destination: destination address\n   *   {string}   methodName: method to invoke on destination\n   *   {Array<*>} params: method params\n   * These are the same parameters as the ones used for `getTransactionPath()`\n   *\n   * Allows user to specify how many of the intents should be checked to ensure their paths are\n   * compatible. `checkMode` supports:\n   *   'all': All intents will be checked to make sure they use the same forwarding path.\n   *   'single': assumes all intents can use the path found from the first intent\n   *\n   * @param  {Array<Array<string, string, Array<*>>>} intentBasket Intents\n   * @param  {Object} [options]\n   * @param  {string} [options.checkMode] Path checking mode\n   * @return {Promise<Object>} An object containing:\n   *   - `path` (Array<Object>): a multi-step transaction path that eventually invokes this basket.\n   *     Empty if no such path could be found.\n   *   - `transactions` (Array<Object>): array of Ethereum transactions that invokes this basket.\n   *     If a multi-step transaction path was found, returns the first transaction in that path.\n   *     Empty if no such transactions could be found.\n   */\n  async getTransactionPathForIntentBasket (intentBasket, { checkMode = 'all' } = {}) {\n    // Get transaction paths for entire basket\n    const intentsToCheck =\n      checkMode === 'all'\n        ? intentBasket // all -- use all intents\n        : checkMode === 'single'\n          ? [intentBasket[0]] // single -- only use first intent\n          : []\n    const intentPaths = await Promise.all(\n      intentsToCheck.map(\n        ([destination, methodName, params]) =>\n          this.getTransactionPath(destination, methodName, params))\n    )\n\n    // If the paths don't match, we can't send the transactions in this intent basket together\n    const pathsMatch = doIntentPathsMatch(intentPaths)\n    if (pathsMatch) {\n      // Create direct transactions for each intent in the intentBasket\n      const sender = (await this.getAccounts())[0] // TODO: don't assume it's the first account\n      const directTransactions = await Promise.all(\n        intentBasket.map(\n          async ([destination, methodName, params]) =>\n            createDirectTransactionForApp(sender, await this.getApp(destination), methodName, params, this.web3)\n        )\n      )\n\n      if (intentPaths[0].length === 1) {\n        // Sender has direct access\n        try {\n          const decoratedTransactions = await this.describeTransactionPath(\n            await Promise.all(\n              directTransactions.map(transaction => this.applyTransactionGas(transaction))\n            )\n          )\n\n          return {\n            path: [],\n            transactions: decoratedTransactions\n          }\n        } catch (_) { }\n      } else {\n        // Need to encode calls scripts for each forwarder transaction in the path\n        const createForwarderTransaction = createForwarderTransactionBuilder(sender, {}, this.web3)\n        const forwarderPath = intentPaths[0]\n          // Ignore the last part of the path, which was the original intent\n          .slice(0, -1)\n          // Start from the \"last\" forwarder and move backwards to the sender\n          .reverse()\n          // Just use the forwarders' addresses\n          .map(({ to }) => to)\n          .reduce(\n            (path, nextForwarder) => {\n              const lastStep = path[0]\n              const encodedLastStep = encodeCallScript(Array.isArray(lastStep) ? lastStep : [lastStep])\n              return [createForwarderTransaction(nextForwarder, encodedLastStep), ...path]\n            },\n            // Start the recursive calls script encoding with the direct transactions for the\n            // intent basket\n            [directTransactions]\n          )\n\n        try {\n          // Put the finishing touches: apply gas, and add radspec descriptions\n          forwarderPath[0] = await this.applyTransactionGas(forwarderPath[0], true)\n          return {\n            path: await this.describeTransactionPath(forwarderPath),\n            // When we have a path, we only need to send the first transaction to start it\n            transactions: [forwarderPath[0]]\n          }\n        } catch (_) { }\n      }\n    }\n\n    // Failed to find a path\n    return {\n      path: [],\n      transactions: []\n    }\n  }\n\n  /**\n   * Get the permission manager for an `app`'s and `role`.\n   *\n   * @param {string} appAddress\n   * @param {string} roleHash\n   * @return {Promise<string>} The permission manager\n   */\n  async getPermissionManager (appAddress, roleHash) {\n    const permissions = await this.permissions.pipe(first()).toPromise()\n    const appPermissions = permissions[appAddress]\n\n    return dotprop.get(appPermissions, `${roleHash}.manager`)\n  }\n\n  /**\n   * Calculates transaction path for performing a method on the ACL\n   *\n   * @param {string} method\n   * @param {Array<*>} params\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path\n   */\n  async getACLTransactionPath (method, params) {\n    const aclAddr = this.aclProxy.address\n\n    const acl = await this.getApp(aclAddr)\n\n    const functionArtifact = acl.functions.find(\n      ({ sig }) => sig.split('(')[0] === method\n    )\n\n    if (!functionArtifact) {\n      throw new Error(`Method ${method} not found on ACL artifact`)\n    }\n\n    if (functionArtifact.roles && functionArtifact.roles.length !== 0) {\n      // createPermission can be done with regular transaction pathing (it has a regular ACL role)\n      return this.getTransactionPath(aclAddr, method, params)\n    } else {\n      // All other ACL functions don't have a role, the manager needs to be provided to aid transaction pathing\n\n      // Inspect ABI to find the position of the 'app' and 'role' parameters needed to get the permission manager\n      const methodABI = acl.abi.find(\n        (item) => item.name === method && item.type === 'function'\n      )\n\n      if (!methodABI) {\n        throw new Error(`Method ${method} not found on ACL ABI`)\n      }\n\n      const inputNames = methodABI.inputs.map((input) => input.name)\n      const appIndex = inputNames.indexOf('_app')\n      const roleIndex = inputNames.indexOf('_role')\n\n      if (appIndex === -1 || roleIndex === -1) {\n        throw new Error(`Method ${method} doesn't take _app and _role as input. Permission manager cannot be found.`)\n      }\n\n      const manager = await this.getPermissionManager(params[appIndex], params[roleIndex])\n\n      return this.getTransactionPath(aclAddr, method, params, manager)\n    }\n  }\n\n  /**\n   * Decodes an EVM callscript and returns the transaction path it describes.\n   *\n   * @param  {string} script\n   * @return {Array<Object>} An array of Ethereum transactions that describe each step in the path\n   */\n  decodeTransactionPath (script) {\n    // In the future we may support more EVMScripts, but for now let's just assume we're only\n    // dealing with call scripts\n    if (!isCallScript(script)) {\n      throw new Error(`Script could not be decoded: ${script}`)\n    }\n\n    const path = decodeCallScript(script)\n    return path.map((segment) => {\n      const { data } = segment\n\n      if (isValidForwardCall(data)) {\n        const forwardedEvmScript = parseForwardCall(data)\n\n        try {\n          segment.children = this.decodeTransactionPath(forwardedEvmScript)\n        } catch (err) {}\n      }\n\n      return segment\n    })\n  }\n\n  /**\n   * Use radspec to create a human-readable description for each transaction in the given `path`\n   *\n   * @param  {Array<Object>} path\n   * @return {Promise<Array<Object>>} The given `path`, with decorated with descriptions at each step\n   */\n  async describeTransactionPath (path) {\n    return Promise.all(path.map(async (step) => {\n      let decoratedStep\n\n      if (Array.isArray(step)) {\n        // Intent basket with multiple transactions in a single callscript\n        // First see if the step can be handled with a specialized descriptor\n        try {\n          decoratedStep = await tryDescribingUpgradeOrganizationBasket(step, this)\n        } catch (err) { }\n\n        // If the step wasn't handled, just individually describe each of the transactions\n        // TODO: annotate this description\n        return decoratedStep || Promise.all(step.map(this.describeTransactionPath))\n      }\n\n      // Single transaction step\n      // First see if the step can be handled with a specialized descriptor\n      try {\n        decoratedStep = await tryDescribingUpdateAppIntent(step, this)\n      } catch (err) { }\n\n      // Finally, if the step wasn't handled yet, evaluate via radspec normally\n      if (!decoratedStep) {\n        try {\n          decoratedStep = await tryEvaluatingRadspec(step, this)\n        } catch (err) { }\n      }\n\n      // Annotate the description, if one was found\n      if (decoratedStep) {\n        if (decoratedStep.description) {\n          try {\n            const processed = await postprocessRadspecDescription(decoratedStep.description, this)\n            decoratedStep.description = processed.description\n            decoratedStep.annotatedDescription = processed.annotatedDescription\n          } catch (err) { }\n        }\n\n        if (decoratedStep.children) {\n          decoratedStep.children = await this.describeTransactionPath(decoratedStep.children)\n        }\n      }\n\n      return decoratedStep || step\n    }))\n  }\n\n  /**\n   * Whether the `sender` can use the `forwarder` to invoke `script`.\n   *\n   * @param  {string} forwarder\n   * @param  {string} sender\n   * @param  {string} script\n   * @return {Promise<bool>}\n   */\n  canForward (forwarder, sender, script) {\n    const canForward = new this.web3.eth.Contract(\n      getAbi('aragon/Forwarder'),\n      forwarder\n    ).methods['canForward']\n\n    return canForward(sender, script).call().catch(() => false)\n  }\n\n  getDefaultGasPrice (gasLimit) {\n    return this.defaultGasPriceFn(gasLimit)\n  }\n\n  /**\n   * Calculates and applies the gas limit and gas price for a transaction\n   *\n   * @param  {Object} transaction\n   * @param  {bool} isForwarding\n   * @return {Promise<Object>} The transaction with the gas limit and gas price added.\n   *                           If the transaction fails from the estimateGas check, the promise will\n   *                           be rejected with the error.\n   */\n  async applyTransactionGas (transaction, isForwarding = false) {\n    // If a pretransaction is required for the main transaction to be performed,\n    // performing web3.eth.estimateGas could fail until the pretransaction is mined\n    // Example: erc20 approve (pretransaction) + deposit to vault (main transaction)\n    if (transaction.pretransaction) {\n      // Calculate gas settings for pretransaction\n      transaction.pretransaction = await this.applyTransactionGas(transaction.pretransaction, false)\n      // Note: for transactions with pretransactions gas limit and price cannot be calculated\n      return transaction\n    }\n\n    // NOTE: estimateGas mutates the argument object and transforms the address to lowercase\n    // so this is a hack to make sure checksums are not destroyed\n    // Also, at the same time it's a hack for checking if the call will revert,\n    // since `eth_call` returns `0x` if the call fails and if the call returns nothing.\n    // So yeah...\n    const estimatedGasLimit = await this.web3.eth.estimateGas({ ...transaction, gas: undefined })\n    const recommendedGasLimit = await getRecommendedGasLimit(this.web3, estimatedGasLimit)\n\n    // If the gas provided in the intent is lower than the estimated gas, use the estimation\n    // when forwarding as it requires more gas and otherwise the transaction would go out of gas\n    if (!transaction.gas || (isForwarding && transaction.gas < recommendedGasLimit)) {\n      transaction.gas = recommendedGasLimit\n    }\n\n    if (!transaction.gasPrice) {\n      transaction.gasPrice = await this.getDefaultGasPrice(transaction.gas)\n    }\n\n    return transaction\n  }\n\n  /**\n   * Calculate the transaction path for a transaction to `destination`\n   * that invokes `methodName` with `params`.\n   *\n   * @param  {string} sender\n   * @param  {string} destination\n   * @param  {string} methodName\n   * @param  {Array<*>} params\n   * @param  {string} [finalForwarder] Address of the final forwarder that can perfom the action.\n   *                  Needed for actions that aren't in the ACL but whose execution depends on other factors\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path\n   */\n  async calculateTransactionPath (sender, destination, methodName, params, finalForwarder) {\n    const finalForwarderProvided = isAddress(finalForwarder)\n\n    const permissions = await this.permissions.pipe(first()).toPromise()\n    const app = await this.getApp(destination)\n    const directTransaction = await createDirectTransactionForApp(sender, app, methodName, params, this.web3)\n\n    let appsWithPermissionForMethod = []\n\n    // Only try to perform direct transaction if no final forwarder is provided or\n    // if the final forwarder is the sender\n    if (!finalForwarderProvided || finalForwarder === sender) {\n      const methods = app.functions\n\n      if (!methods) {\n        throw new Error(`No functions specified in artifact for ${destination}`)\n      }\n\n      // Find method description from the function signatures\n      const method = methods.find(\n        (method) => method.sig.split('(')[0] === methodName\n      )\n      if (!method) {\n        throw new Error(`No method named ${methodName} on ${destination}`)\n      }\n\n      // If the method has no ACL requirements, we assume we\n      // can perform the action directly\n      if (method.roles.length === 0) {\n        try {\n          // `applyTransactionGas` can throw if the transaction will fail\n          // If that happens, we give up as we should've been able to perform the action directly\n          return [await this.applyTransactionGas(directTransaction)]\n        } catch (_) {\n          return []\n        }\n      }\n\n      const roleSig = app.roles.find(\n        (role) => role.id === method.roles[0]\n      ).bytes\n\n      const permissionsForDestination = permissions[destination]\n      appsWithPermissionForMethod = dotprop.get(\n        permissionsForDestination,\n        `${roleSig}.allowedEntities`,\n        []\n      )\n\n      // No one has access, so of course we (or the final forwarder) don't as well\n      if (appsWithPermissionForMethod.length === 0) {\n        return []\n      }\n\n      try {\n        // `applyTransactionGas` can throw if the transaction will fail\n        // If that happens, we will try to find a transaction path through a forwarder\n        return [await this.applyTransactionGas(directTransaction)]\n      } catch (_) { }\n    }\n\n    const forwarders = await this.forwarders.pipe(first()).toPromise().then(\n      (forwarders) => forwarders.map(\n        (forwarder) => forwarder.proxyAddress\n      )\n    )\n\n    let forwardersWithPermission\n\n    if (finalForwarderProvided) {\n      if (!includesAddress(forwarders, finalForwarder)) {\n        return []\n      }\n\n      forwardersWithPermission = [finalForwarder]\n    } else {\n      // Find forwarders with permission to perform the action\n      forwardersWithPermission = forwarders\n        .filter(\n          (forwarder) => includesAddress(appsWithPermissionForMethod, forwarder)\n        )\n    }\n\n    return this.calculateForwardingPath(sender, destination, directTransaction, forwardersWithPermission)\n  }\n\n  /**\n   * Calculate the forwarding path for a transaction to `destination`\n   * that invokes `directTransaction`.\n   *\n   * @param  {string} sender\n   * @param  {string} destination\n   * @param  {Object} directTransaction\n   * @param  {string} [forwardersWithPermission]\n   * @return {Array<Object>} An array of Ethereum transactions that describe each step in the path\n   */\n  async calculateForwardingPath (sender, destination, directTransaction, forwardersWithPermission) {\n    // No forwarders can perform the requested action\n    if (forwardersWithPermission.length === 0) {\n      return []\n    }\n\n    // TODO: handle pretransactions specified in the intent\n    // This is difficult to do generically, as some pretransactions\n    // (e.g. token approvals) only work if they're for a specific target\n    delete directTransaction.pretransaction\n\n    const createForwarderTransaction = createForwarderTransactionBuilder(sender, directTransaction, this.web3)\n\n    // Check if one of the forwarders that has permission to perform an action\n    // with `sig` on `address` can forward for us directly\n    for (const forwarder of forwardersWithPermission) {\n      const script = encodeCallScript([directTransaction])\n      if (await this.canForward(forwarder, sender, script)) {\n        const transaction = createForwarderTransaction(forwarder, script)\n        try {\n          const transactionWithFee = await applyForwardingPretransaction(transaction, this.web3)\n          // `applyTransactionGas` can throw if the transaction will fail\n          // If that happens, we give up as we should've been able to perform the action with this\n          // forwarder\n          return [await this.applyTransactionGas(transactionWithFee, true), directTransaction]\n        } catch (err) {\n          return []\n        }\n      }\n    }\n\n    // Get a list of all forwarders (excluding the forwarders with direct permission)\n    const forwarders = await this.forwarders.pipe(first()).toPromise().then(\n      (forwarders) => forwarders\n        .map((forwarder) => forwarder.proxyAddress)\n        .filter((forwarder) => !includesAddress(forwardersWithPermission, forwarder))\n    )\n\n    // Set up the path finding queue\n    // The queue takes the form of Array<[Array<EthereumTransaction>, Array<String>]>\n    // In other words: it is an array of tuples, where the first index of the tuple\n    // is the current path and the second index of the tuple is the\n    // queue (a list of unexplored forwarder addresses) for that path\n    const queue = forwardersWithPermission.map((forwarderWithPermission) => {\n      return [\n        [\n          createForwarderTransaction(forwarderWithPermission, encodeCallScript([directTransaction])),\n          directTransaction\n        ], forwarders\n      ]\n    })\n\n    // Find the shortest path via a breadth-first search of forwarder paths.\n    // We do a breadth-first instead of depth-first search because:\n    //   - We assume that most forwarding paths will be quite short, so it should be faster\n    //     to check in \"stages\" rather than exhaust single paths\n    //   - We don't currently protect against cycles in the path, and so exhausting single\n    //     paths can be wasteful if they result in dead ends\n    // TODO(onbjerg): Should we find and return multiple paths?\n    do {\n      const [path, [forwarder, ...nextQueue]] = queue.shift()\n\n      // Skip if no forwarder or the path is longer than 5\n      if (!forwarder || path.length > 5) continue\n\n      // Get the previous forwarder address\n      const previousForwarder = path[0].to\n\n      // Encode the previous transaction into an EVM callscript\n      const script = encodeCallScript([path[0]])\n\n      if (await this.canForward(previousForwarder, forwarder, script)) {\n        if (await this.canForward(forwarder, sender, script)) {\n          // The previous forwarder can forward a transaction for this forwarder,\n          // and this forwarder can forward for our address, so we have found a path\n          const transaction = createForwarderTransaction(forwarder, script)\n\n          // Only apply pretransactions and gas to the first transaction in the path\n          // as it's the only one that will be executed by the user\n          try {\n            const transactionWithFee = await applyForwardingPretransaction(transaction, this.web3)\n            // `applyTransactionGas` can throw if the transaction will fail\n            // If that happens, we give up as we should've been able to perform the action with this\n            // forwarding path\n            return [await this.applyTransactionGas(transactionWithFee, true), ...path]\n          } catch (err) {\n            return []\n          }\n        } else {\n          // The previous forwarder can forward a transaction for this forwarder,\n          // but this forwarder can not forward for our address, so we add it as a\n          // possible path in the queue for later exploration.\n          queue.push([\n            [createForwarderTransaction(forwarder, script), ...path],\n            // Avoid including the current forwarder as a candidate for the next step\n            // in the path. Note that this is naive and may result in repeating cycles,\n            // but the maximum path length would prevent against infinite loops\n            forwarders.filter((nextForwarder) => nextForwarder !== forwarder)\n          ])\n        }\n      }\n\n      // We add the current path on the back of the queue again, but we shorten\n      // the list of possible forwarders.\n      queue.push([path, nextQueue])\n    } while (queue.length)\n\n    return []\n  }\n}\n\n// Re-export some web3 utilities\nexport { apm, getRecommendedGasLimit }\nexport { resolve as ensResolve } from './ens'\n\n// Re-export the AddressIdentityProvider abstract base class\nexport { AddressIdentityProvider } from './identity'\n\n// Re-export the Aragon RPC providers\nexport { providers } from '@aragon/rpc-messenger'\n"],"file":"index.js"}